"""
[1]: https://angeris.github.io/papers/cfmm-routing.pdf
"""

from Compiler import mpc_math

class CFMM:
    """
    reserves: list[sfix]
    gamma: sfix
    Ai: list[int]
    """
    def __init__(self, reserves, fee, Ai):
        self.R = reserves
        self.gamma = fee
        self.Ai = Ai

    def phi(self):  
        pass

    def gradient_phi(self):
        pass

    """
    tendered_baskets: Assets to give to CFMM. Delta in [1]
    received_baskets: Assets to receive from CFMM. Lambda in [1]
    """
    def find_arb(self, tendered_baskets, received_baskets, price_vector):
        pass
        

    """
    price_vector: list[sfix]
    reservers: list[sfix]
    invariant: sfix
    fee: sfix
    """
    def arb_delta(self, market_reference_price, reserve, invariant, fee):
        pass

    """
    price_vector: list[sfix]
    reservers: list[sfix]
    invariant: sfix
    fee: sfix
    """
    def arb_lambda(self, market_reference_price, reserve, invariant, fee):
        pass

    def zerotrade(self):
        zerotrade_list = sfix.Array(length=len(self.R))
        zerotrade_list.assign_all(sfix(0))
        return zerotrade_list

class ProductTwoCoinCFMM(CFMM):
    def __init__(self, reserves, fee, Ai):
        assert len(reserves) == 2
        assert len(Ai) == 2
        super().__init__(reserves, fee, Ai)

    def phi(self):
        return self.R[0] * self.R[1]

    def gradient_phi(self):
        R_prime = sfix.Array(len(self.R))
        R_prime[0] = self.R[1]
        R_prime[1] = self.R[0]
        return R_prime

    def find_arb(self, tendered_baskets, received_baskets, price_vector):
        assert len(price_vector) > 0
        is_gamma_nonneg = (self.gamma > 0).if_else(True, False)
        assert is_gamma_nonneg

        k = self.phi()

        tendered_baskets[0] = self.arb_delta(price_vector[1]/price_vector[0], self.R[0], k, self.gamma)
        tendered_baskets[1] = self.arb_delta(price_vector[0]/price_vector[1], self.R[1], k, self.gamma)

        received_baskets[0] = self.arb_lambda(price_vector[0]/price_vector[1], self.R[0], k, self.gamma)
        received_baskets[1] = self.arb_lambda(price_vector[1]/price_vector[0], self.R[1], k, self.gamma)

        return (tendered_baskets, received_baskets)

    def arb_delta(self, market_reference_price, reserve, invariant, fee):
        return ((mpc_math.sqrt(fee*invariant*market_reference_price) - reserve).max(0))/fee

    def arb_lambda(self, market_reference_price, reserve, invariant, fee):
        return ((reserve - mpc_math.sqrt(invariant/(fee*market_reference_price))).max(0))

        

class GeometricMeanTwoCoinCFMM(CFMM):
    pass