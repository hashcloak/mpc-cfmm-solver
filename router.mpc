exec(open("../cfmms.mpc").read())
exec(open("../optimizers.mpc").read())

class ArbitrageRouter:

    """
    cfmms: List[CFMM]
    n_tokens: sint
    tendered_assets: List[List[sfix]]
    received_assets: List[List[sfix]]
    price_vector: List[sfix]
    """
    def __init__(self, cfmms, n_tokens, ln_objective):
        self.cfmms = cfmms
        self.big_delta = MultiArray([len(cfmms), 2], sfix)
        self.big_lambda = MultiArray([len(cfmms), 2], sfix)
        self.linearnn_objective = ln_objective

        @for_range_opt(len(cfmms))
        def _(i):
            self.big_delta.assign_all(sfix(0))
            self.big_lambda.assign_all(sfix(0))

        self.v = sfix.Array(n_tokens)
        self.v.assign_all(sfix(0))

    def find_arb(self, price_vector):
        for i, cfmm in zip(list(range(len(self.cfmms))), self.cfmms):
            #print("from router.find_arb")
            #print(type(price_vector))
            cfmm.find_arb(self.big_delta[i], self.big_lambda[i], price_vector)
            

    def route(self, optimizer, price_vector=None):
        if price_vector is None:
            self.v.assign_all(sfix(1/2)) # OG code says to use initial marginal price here
        else:
            self.v.assign(price_vector)
            #print("from router.route")
            #print(type(self.v))

        
        #NB: Might not need this as it's related to an implementation detail related to Julia's LBFGSB implementation.
        #NB: Maybe there might be a way to leverage this to make the computation faster. To be explored later. 
        def fn(v):
            tmp = Matrix(len(self.v), 1, sfix)
            @for_range(len(self.v))
            def _(i):
                tmp[i].assign(((v[i][0] <= self.v[i][0]).if_else(0, 1)))

            @if_((tmp[:] == 0).reveal())
            def _():
                self.find_arb(v)
                self.v.assign(v)

            accumulator = sfix(0)

            for (big_delta, big_lambda, cfmm) in zip(self.big_delta, self.big_lambda, self.cfmms):
                #print("from router.mpc")
                #print(type(v))
                #print(type(v[cfmm.Ai]))
                tmp_big_delta = Matrix(len(big_delta), 1, sfix)
                tmp_big_lambda = Matrix(len(big_lambda), 1, sfix)
                #print(type(tmp_big_lambda))
                #print(type(v.get_vector_by_indices(*cfmm.Ai)))
                accumulator += (tmp_big_lambda.dot(v.get_vector_by_indices(*cfmm.Ai)) - tmp_big_delta.dot(v.get_vector_by_indices(*cfmm.Ai)))

            return self.linearnn_objective.conjugate(v)[:] + accumulator

        def g(v):
            G = Matrix(len(self.v), 1, sfix) 
            #G = sfix.Array(2)

            tmp = Matrix(len(self.v), 1, sfix)
            #tmp = []
            @for_range(len(self.v))
            def _(i):
                tmp[i].assign(((v[i][0] <= self.v[i][0]).if_else(0, 1)))

            @if_((tmp[:] == 0).reveal())
            def _():
                #tmp_v = Array.create_from(v)
                self.find_arb(v)
                self.v.assign(v)

            """
            if not all(tmp):
                self.find_arb(v)
                self.v.assign(v)
            """

            G.assign(self.linearnn_objective.grad(v))
            #print("from router.mpc")
            #print(type(G))

            for big_delta, big_lambda, c in zip(self.big_delta, self.big_lambda, self.cfmms):
                #print("from router.mpc")
                #print(type(c.Ai))
                tmp2 = G.get_slice_vector(c.Ai) 
                tmp2 += (big_lambda - big_delta)
                G.assign(tmp2)

            return G
        

        self.find_arb(self.v)
        new_price_vector = optimizer.optimize(self.v, fn, g, threshold=cfix(1))[0]
        #print_ln("router.v: %s", new_price_vector.reveal())
        self.v.assign(new_price_vector)
        #print("from router.route")
        #print(type(self.v))
        self.find_arb(self.v)


    def netflows(self):
        psi = Matrix(len(self.v), 1, sfix)
        for (big_delta, big_lambda, cfmm) in zip(self.big_delta, self.big_lambda, self.cfmms):
            tmp = big_lambda - big_delta
            for i in cfmm.Ai:
                psi[i] = tmp[i]
        return psi