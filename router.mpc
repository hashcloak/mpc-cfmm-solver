exec(open("../cfmms.mpc").read())
exec(open("../optimizers.mpc").read())

class ArbitrageRouter:

    """
    cfmms: List[CFMM]
    n_tokens: sint
    tendered_assets: List[List[sfix]]
    received_assets: List[List[sfix]]
    price_vector: List[sfix]
    """
    def __init__(self, cfmms, n_tokens, ln_objective):
        self.cfmms = cfmms
        self.big_delta = MultiArray([len(cfmms), 2], sfix)
        self.big_lambda = MultiArray([len(cfmms), 2], sfix)
        self.linearnn_objective = ln_objective

        @for_range(len(cfmms))
        def _(i):
            self.big_delta.assign_all(sfix(0))
            self.big_lambda.assign_all(sfix(0))

        self.v = sfix.Array(n_tokens)
        self.v.assign_all(sfix(0))

    def find_arb(self, price_vector):
        for i, cfmm in zip(list(range(len(self.cfmms))), self.cfmms):
            cfmm.find_arb(self.big_delta[i], self.big_lambda[i], price_vector)
            

    def route(self, optimizer, price_vector=None):
        if price_vector is None:
            self.v.assign_all(sfix(1)) # OG code says to use initial marginal price here
        else:
            self.v.assign(price_vector)

        """
        NB: Might not need this as it's related to an implementation detail related to Julia's LBFGSB implementation.
        NB: Maybe there might be a way to leverage this to make the computation faster. To be explored later. 
        def fn(v):
            tmp = []
            @for_range(len(self.constants))
            def _(i):
                tmp.append((self.constants[i][0] <= v[i][0]).if_else(0, False))

            if !all(tmp):
                self.find_arb(v)
                self.price_vector.assign(v)

            accumulator = sfix(0)

            for (big_delta, big_lambda, cfmm) in zip(self.big_delta, self.big_lambda, self.cfmms):
                accumulator += (big_lambda.dot(v[cfmm.Ai]) - big_delta.dot(v[cfmm.Ai]))

            return self.linearnn_objective.conjugate(v) + accumulator

        def g(v):
            pass
        """

        self.find_arb(self.v)
        new_price_vector = optimizer.optimize(self.v)[0]
        self.v.assign(new_price_vector)
        self.find_arb(self.v)


    def netflows(self):
        psi = Matrix(len(self.v), 1, sfix)
        for (big_delta, big_lambda, cfmm) in zip(self.big_delta, self.big_lambda, self.cfmms):
            tmp = big_lambda - big_delta
            for i in cfmm.Ai:
                psi[i] = tmp[i]
        return psi